export parse_universe

using Basic.Utils: YAML, JSON, filepath
import YAML as YAMLLib
import JSON3

# Standard location where the universe has to be saved 
const DEF_UNIVERSE_FILE = joinpath(@__DIR__, "..", "..", "gen/src", "temp.jl")

# Order in which the universe entries shall be evaluated
# This is needed since some entries do depends on others
const UNIVERSE_EVAL_SEQ = (
    :mappings,
    :constants, 
    :ephemeris, 
    :bodies, 
    :connections, 
    :frames
) 

function _parse_universe(configfile::YAML)
    YAMLLib.load_file(filepath(configfile); dicttype=OrderedDict{String, Any})
end

function _parse_universe(configfile::JSON) 
    open(filepath(configfile), "r") do f 
        data = JSON3.read(f, OrderedDict{String, Any})
        return data
    end
end

"""
    parse_universe(configfile::Union{YAML, JSON}, file::String=DEF_UNIVERSE_FILE)

Parse universe `Basic` autogenerated files from configuration and saved it in `file`.
This performs the `configfile` validation before the autogen runners are 
initialized. 
"""
function parse_universe(configfile::Union{YAML, JSON}, file::String=DEF_UNIVERSE_FILE)
    config = _parse_universe(configfile)
    # insert generated configfile at the top 
    raw = join(["#@config $line" for line in Base.readlines(filepath(configfile))], "\n")
    fileid = bytes2hex(sha256(raw))

    data = OrderedDict()
    push!(data, :gen => Vector{Tuple{GenMeta, String}}())
    push!(data[:gen], (GenMeta("Universe/@config", fileid), raw))

    # validation step 
    if isvaliduniverse(config)
        # the universe entries are parsed using helper functions in this module
        # each universe 1st level entries shall have the same names as the 
        # helper functions. For example, if the `configfile` has `bodies, mappings`
        # then there shall be two helper function `parse_bodies` and `parse_mappings`
        # in the Universe module, otherwise an error is throw. 
        #
        # The helper functions shall work directly on the `data` dictionary
        # and include there the autogen code (under the :gen key).
        #
        # TODO: this `data` dict shall be replaced with a proper type parsed using StructTypes
        for k in UNIVERSE_EVAL_SEQ
            if haskey(config, String(k))
                parser = Symbol("parse_$(k)!")
                @info "[Universe] Parsing $k..."
                @eval begin 
                    $parser($data, $config)
                end
            end
        end
    else
        # if not valid, throw error
        validate(UniverseSchema, config)
        throw(error("[Universe] Input universe file is not valid!"))
    end
    # once the variables needed for the universe are parsed, then the universe 
    # file is parsed and written in `file`
    if length(data[:gen]) > 0
        gen = _parse_generated(file, data[:gen])  
        write(gen)
    end
    return data 
end

function _parse_generated(filename, data)
    GEN(
        filename, 
        [meta for (meta, _) in data],
        [gen for (_, gen) in data],
    )
end

# apply autogen template to the `GEN` type entries - DO NOT EDIT
function writelines(gen::GEN)
    s = ""
    for (m, d) in zip(gen.meta, gen.body)
        meta = template_metadata(m.generated, m.id)
        data = template_generated(d)
        s *= meta*"\n"*data 
    end
    return s
end

# write `GEN` function type
function write(gen::GEN)
    lines = split(writelines(gen), "\n")
    open(gen.path, "w") do f 
        for line in lines
            Base.write(f, line)
            Base.write(f, "\n")
        end
    end
    nothing
end